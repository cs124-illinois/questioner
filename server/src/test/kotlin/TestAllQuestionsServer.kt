package edu.illinois.cs.cs125.questioner.server

import edu.illinois.cs.cs125.questioner.lib.Language
import edu.illinois.cs.cs125.questioner.lib.server.Submission
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

/**
 * Tests that all validated questions pass when tested cold through the server path.
 *
 * This test loads questions from questions.json (generated by plugin:functionalTest)
 * and tests each solution through submission.test() WITHOUT calling validate() first.
 * This exercises the same code path that the actual server uses.
 *
 * This catches issues where validation-time measurements differ from test-time measurements,
 * such as memory allocation baselines that don't account for cold execution.
 */
class TestAllQuestionsServer :
    StringSpec({

        "all questions should pass when solution is tested cold via submission.test()" {
            val failures = mutableListOf<String>()

            for ((path, question) in Loader.questions) {
                // Skip questions that aren't validated
                if (!question.validated) continue

                for (language in question.published.languages) {
                    val solution = question.getCorrect(language) ?: continue

                    val submission = Submission(
                        type = Submission.SubmissionType.SOLVE,
                        contentHash = question.published.contentHash,
                        language = language,
                        contents = solution,
                    )

                    val response = submission.test(question)
                    val results = response.solveResults ?: continue

                    // Check that the solution passes
                    if (!results.succeeded) {
                        failures.add("$path ($language): ${results.summary}")
                        continue
                    }

                    // Check that resource comparisons don't fail
                    results.complete.memoryAllocation?.let {
                        if (it.failed) {
                            failures.add(
                                "$path ($language): Memory allocation failed - " +
                                    "solution=${it.solution}, submission=${it.submission}, limit=${it.limit}",
                            )
                        }
                    }

                    results.complete.executionCount?.let {
                        if (it.failed) {
                            failures.add(
                                "$path ($language): Execution count failed - " +
                                    "solution=${it.solution}, submission=${it.submission}, limit=${it.limit}",
                            )
                        }
                    }

                    results.complete.coverage?.let {
                        if (it.failed) {
                            failures.add(
                                "$path ($language): Coverage failed - " +
                                    "missed ${it.submission.missed} lines (limit ${it.limit})",
                            )
                        }
                    }
                }
            }

            if (failures.isNotEmpty()) {
                println("=== Failed Questions ===")
                failures.forEach { println(it) }
                println()
            }

            failures.size shouldBe 0
        }
    })

package edu.illinois.cs.cs125.questioner.lib

import edu.illinois.cs.cs125.questioner.lib.serialization.json
import io.kotest.core.spec.style.StringSpec
import io.kotest.matchers.shouldBe

/**
 * Tests that all validated questions pass when tested cold (without re-validation).
 *
 * This test loads questions from questions.json (generated by plugin:functionalTest)
 * and tests each solution WITHOUT calling validate() first. This catches issues where
 * validation-time measurements differ from test-time measurements, such as:
 * - Memory allocation baselines set during JIT-optimized validation don't match cold execution
 * - Execution count baselines that assume warmed-up code paths
 *
 * If this test fails, it typically means validation is recording different resource usage
 * than what occurs during actual testing.
 */
class TestAllQuestions : StringSpec({

    "all questions should pass when solution is tested cold" {
        // Load questions fresh from JSON - do NOT call validate()
        val questions = json.decodeFromString<List<Question>>(
            object {}::class.java.getResource("/questions.json")!!.readText()
        )

        val failures = mutableListOf<String>()

        for (question in questions) {
            // Skip questions that aren't validated
            if (!question.validated) continue

            for (language in question.published.languages) {
                val solution = question.getCorrect(language) ?: continue

                val results = question.test(solution, language, isSolution = true)

                // Check that the solution passes
                if (!results.succeeded) {
                    failures.add("${question.published.path} ($language): ${results.summary}")
                    continue
                }

                // Check that resource comparisons don't fail
                results.complete.memoryAllocation?.let {
                    if (it.failed) {
                        failures.add(
                            "${question.published.path} ($language): Memory allocation failed - " +
                                "solution=${it.solution}, submission=${it.submission}, limit=${it.limit}"
                        )
                    }
                }

                results.complete.executionCount?.let {
                    if (it.failed) {
                        failures.add(
                            "${question.published.path} ($language): Execution count failed - " +
                                "solution=${it.solution}, submission=${it.submission}, limit=${it.limit}"
                        )
                    }
                }

                results.complete.coverage?.let {
                    if (it.failed) {
                        failures.add(
                            "${question.published.path} ($language): Coverage failed - " +
                                "missed ${it.submission.missed} lines (limit ${it.limit})"
                        )
                    }
                }
            }
        }

        if (failures.isNotEmpty()) {
            println("=== Failed Questions ===")
            failures.forEach { println(it) }
            println()
        }

        failures.size shouldBe 0
    }
})
